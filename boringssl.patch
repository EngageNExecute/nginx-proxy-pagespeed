Index: CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>cmake_minimum_required (VERSION 2.8.10)\n\nproject (BoringSSL)\n\nif(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n  set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wall -Werror -ggdb -fvisibility=hidden\")\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wall -Werror -ggdb -std=c++0x -fvisibility=hidden\")\nelseif(MSVC)\n  set(MSVC_DISABLED_WARNINGS_LIST\n      \"C4100\" # 'exarg' : unreferenced formal parameter\n      \"C4127\" # conditional expression is constant\n      \"C4200\" # nonstandard extension used : zero-sized array in\n              # struct/union.\n      \"C4210\" # nonstandard extension used : function given file scope\n      \"C4242\" # 'function' : conversion from 'int' to 'uint8_t',\n              # possible loss of data\n      \"C4244\" # 'function' : conversion from 'int' to 'uint8_t',\n              # possible loss of data\n      \"C4245\" # 'initializing' : conversion from 'long' to\n              # 'unsigned long', signed/unsigned mismatch\n      \"C4267\" # conversion from 'size_t' to 'int', possible loss of data\n      \"C4311\" # 'type cast' : pointer truncation from 'uint8_t *' to 'long'\n              # TODO(davidben): Fix the s3_pkt.c's alignment code to avoid this.\n      \"C4371\" # layout of class may have changed from a previous version of the\n              # compiler due to better packing of member '...'\n      \"C4388\" # signed/unsigned mismatch\n      \"C4296\" # '>=' : expression is always true\n      \"C4350\" # behavior change: 'std::_Wrap_alloc...'\n      \"C4365\" # '=' : conversion from 'size_t' to 'int',\n              # signed/unsigned mismatch\n      \"C4389\" # '!=' : signed/unsigned mismatch\n      \"C4510\" # 'argument' : default constructor could not be generated\n      \"C4512\" # 'argument' : assignment operator could not be generated\n      \"C4514\" # 'function': unreferenced inline function has been removed\n      \"C4548\" # expression before comma has no effect; expected expression with\n              # side-effect\" caused by FD_* macros.\n      \"C4610\" # struct 'argument' can never be instantiated - user defined\n              # constructor required.\n      \"C4625\" # copy constructor could not be generated because a base class\n              # copy constructor is inaccessible or deleted\n      \"C4626\" # assignment operator could not be generated because a base class\n              # assignment operator is inaccessible or deleted\n      \"C4701\" # potentially uninitialized local variable 'mdlen' used\n      \"C4706\" # assignment within conditional expression\n      \"C4710\" # 'function': function not inlined\n      \"C4711\" # function 'function' selected for inline expansion\n      \"C4800\" # 'int' : forcing value to bool 'true' or 'false'\n              # (performance warning)\n      \"C4820\" # 'bytes' bytes padding added after construct 'member_name'\n      \"C4996\" # 'read': The POSIX name for this item is deprecated. Instead,\n              # use the ISO C++ conformant name: _read.\n     )\n  string(REPLACE \"C\" \" -wd\" MSVC_DISABLED_WARNINGS_STR\n                            ${MSVC_DISABLED_WARNINGS_LIST})\n  set(CMAKE_C_FLAGS   \"-Wall -WX ${MSVC_DISABLED_WARNINGS_STR}\")\n  set(CMAKE_CXX_FLAGS \"-Wall -WX ${MSVC_DISABLED_WARNINGS_STR}\")\n  add_definitions(-D_HAS_EXCEPTIONS=0)\n  add_definitions(-DWIN32_LEAN_AND_MEAN)\nendif()\n\nif((CMAKE_COMPILER_IS_GNUCXX AND CMAKE_C_COMPILER_VERSION VERSION_GREATER \"4.5.99\") OR\n   CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n  set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wshadow\")\n  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wshadow\")\nendif()\n\nadd_definitions(-DBORINGSSL_IMPLEMENTATION)\n\nif (BUILD_SHARED_LIBS)\n  add_definitions(-DBORINGSSL_SHARED_LIBRARY)\n  # Enable position-independent code globally. This is needed because\n  # some library targets are OBJECT libraries.\n  set(CMAKE_POSITION_INDEPENDENT_CODE TRUE)\nendif()\n\nif (${CMAKE_SYSTEM_PROCESSOR} STREQUAL \"x86_64\")\n  set(ARCH \"x86_64\")\nelseif (${CMAKE_SYSTEM_PROCESSOR} STREQUAL \"amd64\")\n  set(ARCH \"x86_64\")\nelseif (${CMAKE_SYSTEM_PROCESSOR} STREQUAL \"AMD64\")\n  # cmake reports AMD64 on Windows, but we might be building for 32-bit.\n  if (CMAKE_CL_64)\n    set(ARCH \"x86_64\")\n  else()\n    set(ARCH \"x86\")\n  endif()\nelseif (${CMAKE_SYSTEM_PROCESSOR} STREQUAL \"x86\")\n  set(ARCH \"x86\")\nelseif (${CMAKE_SYSTEM_PROCESSOR} STREQUAL \"i386\")\n  set(ARCH \"x86\")\nelseif (${CMAKE_SYSTEM_PROCESSOR} STREQUAL \"i686\")\n  set(ARCH \"x86\")\nelseif (${CMAKE_SYSTEM_PROCESSOR} STREQUAL \"arm\")\n  set(ARCH \"arm\")\nelseif (${CMAKE_SYSTEM_PROCESSOR} STREQUAL \"aarch64\")\n  set(ARCH \"aarch64\")\nelse()\n  message(FATAL_ERROR \"Unknown processor:\" ${CMAKE_SYSTEM_PROCESSOR})\nendif()\n\nif (${ARCH} STREQUAL \"x86\" AND APPLE)\n  # With CMake 2.8.x, ${CMAKE_SYSTEM_PROCESSOR} evalutes to i386 on OS X,\n  # but clang defaults to 64-bit builds on OS X unless otherwise told.\n  # Set ARCH to x86_64 so clang and CMake agree. This is fixed in CMake 3.\n  set(ARCH \"x86_64\")\nendif()\n\nadd_subdirectory(crypto)\nadd_subdirectory(ssl)\nadd_subdirectory(ssl/test)\nadd_subdirectory(tool)\n
===================================================================
--- CMakeLists.txt	(revision 5f237bc843f4a4791667493d8748c903b8e540e4)
+++ CMakeLists.txt	(revision )
@@ -3,8 +3,8 @@
 project (BoringSSL)
 
 if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
-  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Werror -ggdb -fvisibility=hidden")
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Werror -ggdb -std=c++0x -fvisibility=hidden")
+  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -O2 -fpic -std=c89 -fvisibility=hidden")
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -O2 -std=c++0x -fvisibility=hidden")
 elseif(MSVC)
   set(MSVC_DISABLED_WARNINGS_LIST
       "C4100" # 'exarg' : unreferenced formal parameter
@@ -107,5 +107,4 @@
 
 add_subdirectory(crypto)
 add_subdirectory(ssl)
-add_subdirectory(ssl/test)
-add_subdirectory(tool)
+
Index: crypto/err/err.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n * All rights reserved.\n *\n * This package is an SSL implementation written\n * by Eric Young (eay@cryptsoft.com).\n * The implementation was written so as to conform with Netscapes SSL.\n *\n * This library is free for commercial and non-commercial use as long as\n * the following conditions are aheared to.  The following conditions\n * apply to all code found in this distribution, be it the RC4, RSA,\n * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n * included with this distribution is covered by the same copyright terms\n * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n *\n * Copyright remains Eric Young's, and as such any Copyright notices in\n * the code are not to be removed.\n * If this package is used in a product, Eric Young should be given attribution\n * as the author of the parts of the library used.\n * This can be in the form of a textual message at program startup or\n * in documentation (online or textual) provided with the package.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *    \"This product includes cryptographic software written by\n *     Eric Young (eay@cryptsoft.com)\"\n *    The word 'cryptographic' can be left out if the rouines from the library\n *    being used are not cryptographic related :-).\n * 4. If you include any Windows specific code (or a derivative thereof) from\n *    the apps directory (application code) you must include an acknowledgement:\n *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n *\n * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * The licence and distribution terms for any publically available version or\n * derivative of this code cannot be changed.  i.e. this code cannot simply be\n * copied and put under another distribution licence\n * [including the GNU Public Licence.]\n */\n/* ====================================================================\n * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    openssl-core@openssl.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.openssl.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com). */\n\n#include <openssl/err.h>\n\n#include <assert.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n\n#if defined(OPENSSL_WINDOWS)\n#pragma warning(push, 3)\n#include <Windows.h>\n#pragma warning(pop)\n#endif\n\n#include <openssl/lhash.h>\n#include <openssl/mem.h>\n#include <openssl/thread.h>\n\n\n/* err_fns contains a pointer to the current error implementation. */\nstatic const struct ERR_FNS_st *err_fns = NULL;\nextern const struct ERR_FNS_st openssl_err_default_impl;\n\n#define ERRFN(a) err_fns->a\n\n/* err_fns_check is an internal function that checks whether \"err_fns\" is set\n * and if not, sets it to the default. */\nstatic void err_fns_check(void) {\n  /* In practice, this is not a race problem because loading the error strings\n   * at init time will cause this pointer to be set before the process goes\n   * multithreaded. */\n  if (err_fns) {\n    return;\n  }\n\n  CRYPTO_w_lock(CRYPTO_LOCK_ERR);\n  if (!err_fns) {\n    err_fns = &openssl_err_default_impl;\n  }\n  CRYPTO_w_unlock(CRYPTO_LOCK_ERR);\n}\n\n/* err_clear_data frees the optional |data| member of the given error. */\nstatic void err_clear_data(struct err_error_st *error) {\n  if (error->data != NULL && (error->flags & ERR_FLAG_MALLOCED) != 0) {\n    OPENSSL_free(error->data);\n  }\n  error->data = NULL;\n  error->flags &= ~ERR_FLAG_MALLOCED;\n}\n\n/* err_clear clears the given queued error. */\nstatic void err_clear(struct err_error_st *error) {\n  err_clear_data(error);\n  memset(error, 0, sizeof(struct err_error_st));\n}\n\n/* err_get_state gets the ERR_STATE object for the current thread. */\nstatic ERR_STATE *err_get_state(void) {\n  err_fns_check();\n  return ERRFN(get_state)();\n}\n\nstatic uint32_t get_error_values(int inc, int top, const char **file, int *line,\n                                 const char **data, int *flags) {\n  unsigned i = 0;\n  ERR_STATE *state;\n  struct err_error_st *error;\n  uint32_t ret;\n\n  state = err_get_state();\n  if (state == NULL || state->bottom == state->top) {\n    return 0;\n  }\n\n  if (top) {\n    assert(!inc);\n    /* last error */\n    i = state->top;\n  } else {\n    i = (state->bottom + 1) % ERR_NUM_ERRORS;\n  }\n\n  error = &state->errors[i];\n  ret = error->packed;\n\n  if (file != NULL && line != NULL) {\n    if (error->file == NULL) {\n      *file = \"NA\";\n      *line = 0;\n    } else {\n      *file = error->file;\n      *line = error->line;\n    }\n  }\n\n  if (data != NULL) {\n    if (error->data == NULL) {\n      *data = \"\";\n      if (flags != NULL) {\n        *flags = 0;\n      }\n    } else {\n      *data = error->data;\n      if (flags != NULL) {\n        *flags = error->flags & ERR_FLAG_PUBLIC_MASK;\n      }\n      /* If this error is being removed, take ownership of data from\n       * the error. The semantics are such that the caller doesn't\n       * take ownership either. Instead the error system takes\n       * ownership and retains it until the next call that affects the\n       * error queue. */\n      if (inc) {\n        if (error->flags & ERR_FLAG_MALLOCED) {\n          if (state->to_free) {\n            OPENSSL_free(state->to_free);\n          }\n          state->to_free = error->data;\n        }\n        error->data = NULL;\n        error->flags = 0;\n      }\n    }\n  }\n\n  if (inc) {\n    assert(!top);\n    err_clear(error);\n    state->bottom = i;\n  }\n\n  return ret;\n}\n\nuint32_t ERR_get_error(void) {\n  return get_error_values(1, 0, NULL, NULL, NULL, NULL);\n}\n\nuint32_t ERR_get_error_line(const char **file, int *line) {\n  return get_error_values(1, 0, file, line, NULL, NULL);\n}\n\nuint32_t ERR_get_error_line_data(const char **file, int *line,\n                                 const char **data, int *flags) {\n  return get_error_values(1, 0, file, line, data, flags);\n}\n\nuint32_t ERR_peek_error(void) {\n  return get_error_values(0, 0, NULL, NULL, NULL, NULL);\n}\n\nuint32_t ERR_peek_error_line(const char **file, int *line) {\n  return get_error_values(0, 0, file, line, NULL, NULL);\n}\n\nuint32_t ERR_peek_error_line_data(const char **file, int *line,\n                                  const char **data, int *flags) {\n  return get_error_values(0, 0, file, line, data, flags);\n}\n\nuint32_t ERR_peek_last_error(void) {\n  return get_error_values(0, 1, NULL, NULL, NULL, NULL);\n}\n\nuint32_t ERR_peek_last_error_line(const char **file, int *line) {\n  return get_error_values(0, 1, file, line, NULL, NULL);\n}\n\nuint32_t ERR_peek_last_error_line_data(const char **file, int *line,\n                                       const char **data, int *flags) {\n  return get_error_values(0, 1, file, line, data, flags);\n}\n\nvoid ERR_clear_error(void) {\n  ERR_STATE *const state = err_get_state();\n  unsigned i;\n\n  if (state == NULL) {\n    return;\n  }\n\n  for (i = 0; i < ERR_NUM_ERRORS; i++) {\n    err_clear(&state->errors[i]);\n  }\n  if (state->to_free) {\n    OPENSSL_free(state->to_free);\n    state->to_free = NULL;\n  }\n\n  state->top = state->bottom = 0;\n}\n\nstatic void err_state_free(ERR_STATE *state) {\n  unsigned i;\n\n  for (i = 0; i < ERR_NUM_ERRORS; i++) {\n    err_clear(&state->errors[i]);\n  }\n  if (state->to_free) {\n    OPENSSL_free(state->to_free);\n  }\n  OPENSSL_free(state);\n}\n\nvoid ERR_remove_thread_state(const CRYPTO_THREADID *tid) {\n  CRYPTO_THREADID current;\n  ERR_STATE *state;\n\n  if (tid == NULL) {\n    CRYPTO_THREADID_current(&current);\n    tid = &current;\n  }\n\n  err_fns_check();\n  state = ERRFN(release_state)(tid);\n  if (state == NULL) {\n    return;\n  }\n\n  err_state_free(state);\n}\n\nint ERR_get_next_error_library(void) {\n  err_fns_check();\n  return ERRFN(get_next_library)();\n}\n\nvoid ERR_clear_system_error(void) {\n  errno = 0;\n}\n\nchar *ERR_error_string(uint32_t packed_error, char *ret) {\n  static char buf[ERR_ERROR_STRING_BUF_LEN];\n\n  if (ret == NULL) {\n    /* TODO(fork): remove this. */\n    ret = buf;\n  }\n\n#if !defined(NDEBUG)\n  /* This is aimed to help catch callers who don't provide\n   * |ERR_ERROR_STRING_BUF_LEN| bytes of space. */\n  memset(ret, 0, ERR_ERROR_STRING_BUF_LEN);\n#endif\n\n  ERR_error_string_n(packed_error, ret, ERR_ERROR_STRING_BUF_LEN);\n\n  return ret;\n}\n\nvoid ERR_error_string_n(uint32_t packed_error, char *buf, size_t len) {\n  char lib_buf[64], func_buf[64], reason_buf[64];\n  const char *lib_str, *func_str, *reason_str;\n  unsigned lib, func, reason;\n\n  if (len == 0) {\n    return;\n  }\n\n  lib = ERR_GET_LIB(packed_error);\n  func = ERR_GET_FUNC(packed_error);\n  reason = ERR_GET_REASON(packed_error);\n\n  lib_str = ERR_lib_error_string(packed_error);\n  func_str = ERR_func_error_string(packed_error);\n  reason_str = ERR_reason_error_string(packed_error);\n\n  if (lib_str == NULL) {\n    BIO_snprintf(lib_buf, sizeof(lib_buf), \"lib(%u)\", lib);\n    lib_str = lib_buf;\n  }\n\n  if (func_str == NULL) {\n    BIO_snprintf(func_buf, sizeof(func_buf), \"func(%u)\", func);\n    func_str = func_buf;\n  }\n\n  if (reason_str == NULL) {\n    BIO_snprintf(reason_buf, sizeof(reason_buf), \"reason(%u)\", reason);\n    reason_str = reason_buf;\n  }\n\n  BIO_snprintf(buf, len, \"error:%08\" PRIx32 \":%s:%s:%s\",\n               packed_error, lib_str, func_str, reason_str);\n\n  if (strlen(buf) == len - 1) {\n    /* output may be truncated; make sure we always have 5 colon-separated\n     * fields, i.e. 4 colons. */\n    static const unsigned num_colons = 4;\n    unsigned i;\n    char *s = buf;\n\n    if (len <= num_colons) {\n      /* In this situation it's not possible to ensure that the correct number\n       * of colons are included in the output. */\n      return;\n    }\n\n    for (i = 0; i < num_colons; i++) {\n      char *colon = strchr(s, ':');\n      char *last_pos = &buf[len - 1] - num_colons + i;\n\n      if (colon == NULL || colon > last_pos) {\n        /* set colon |i| at last possible position (buf[len-1] is the\n         * terminating 0). If we're setting this colon, then all whole of the\n         * rest of the string must be colons in order to have the correct\n         * number. */\n        memset(last_pos, ':', num_colons - i);\n        break;\n      }\n\n      s = colon + 1;\n    }\n  }\n}\n\n#include \"err_data.h\"\n\n// err_string_cmp is a compare function for searching error values with\n// |bsearch| in |err_string_lookup|.\nstatic int err_string_cmp(const void *a, const void *b) {\n  const uint32_t a_key = *((const uint32_t*) a) >> 15;\n  const uint32_t b_key = *((const uint32_t*) b) >> 15;\n\n  if (a_key < b_key) {\n    return -1;\n  } else if (a_key > b_key) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\n/* err_string_lookup looks up the string associated with |lib| and |key| in\n * |values| and |string_data|. It returns the string or NULL if not found. */\nstatic const char *err_string_lookup(uint32_t lib, uint32_t key,\n                                     const uint32_t *values,\n                                     size_t num_values,\n                                     const char *string_data) {\n  /* |values| points to data in err_data.h, which is generated by\n   * err_data_generate.go. It's an array of uint32_t values. Each value has the\n   * following structure:\n   *   | lib  |    key    |    offset     |\n   *   |6 bits|  11 bits  |    15 bits    |\n   *\n   * The |lib| value is a library identifier: one of the |ERR_LIB_*| values.\n   * The |key| is either a function or a reason code, depending on the context.\n   * The |offset| is the number of bytes from the start of |string_data| where\n   * the (NUL terminated) string for this value can be found.\n   *\n   * Values are sorted based on treating the |lib| and |key| part as an\n   * unsigned integer. */\n  if (lib >= (1 << 6) || key >= (1 << 11)) {\n    return NULL;\n  }\n  uint32_t search_key = lib << 26 | key << 15;\n  const uint32_t *result = bsearch(&search_key, values, num_values,\n                                   sizeof(uint32_t), err_string_cmp);\n  if (result == NULL) {\n    return NULL;\n  }\n\n  return &string_data[(*result) & 0x7fff];\n}\n\nstatic const char *const kLibraryNames[ERR_NUM_LIBS] = {\n    \"invalid library (0)\",\n    \"unknown library\",                            /* ERR_LIB_NONE */\n    \"system library\",                             /* ERR_LIB_SYS */\n    \"bignum routines\",                            /* ERR_LIB_BN */\n    \"RSA routines\",                               /* ERR_LIB_RSA */\n    \"Diffie-Hellman routines\",                    /* ERR_LIB_DH */\n    \"public key routines\",                        /* ERR_LIB_EVP */\n    \"memory buffer routines\",                     /* ERR_LIB_BUF */\n    \"object identifier routines\",                 /* ERR_LIB_OBJ */\n    \"PEM routines\",                               /* ERR_LIB_PEM */\n    \"DSA routines\",                               /* ERR_LIB_DSA */\n    \"X.509 certificate routines\",                 /* ERR_LIB_X509 */\n    \"ASN.1 encoding routines\",                    /* ERR_LIB_ASN1 */\n    \"configuration file routines\",                /* ERR_LIB_CONF */\n    \"common libcrypto routines\",                  /* ERR_LIB_CRYPTO */\n    \"elliptic curve routines\",                    /* ERR_LIB_EC */\n    \"SSL routines\",                               /* ERR_LIB_SSL */\n    \"BIO routines\",                               /* ERR_LIB_BIO */\n    \"PKCS7 routines\",                             /* ERR_LIB_PKCS7 */\n    \"PKCS8 routines\",                             /* ERR_LIB_PKCS8 */\n    \"X509 V3 routines\",                           /* ERR_LIB_X509V3 */\n    \"random number generator\",                    /* ERR_LIB_RAND */\n    \"ENGINE routines\",                            /* ERR_LIB_ENGINE */\n    \"OCSP routines\",                              /* ERR_LIB_OCSP */\n    \"UI routines\",                                /* ERR_LIB_UI */\n    \"COMP routines\",                              /* ERR_LIB_COMP */\n    \"ECDSA routines\",                             /* ERR_LIB_ECDSA */\n    \"ECDH routines\",                              /* ERR_LIB_ECDH */\n    \"HMAC routines\",                              /* ERR_LIB_HMAC */\n    \"Digest functions\",                           /* ERR_LIB_DIGEST */\n    \"Cipher functions\",                           /* ERR_LIB_CIPHER */\n    \"User defined functions\",                     /* ERR_LIB_USER */\n    \"HKDF functions\",                             /* ERR_LIB_HKDF */\n};\n\nconst char *ERR_lib_error_string(uint32_t packed_error) {\n  const uint32_t lib = ERR_GET_LIB(packed_error);\n\n  if (lib >= ERR_NUM_LIBS) {\n    return NULL;\n  }\n  return kLibraryNames[lib];\n}\n\nconst char *ERR_func_error_string(uint32_t packed_error) {\n  const uint32_t lib = ERR_GET_LIB(packed_error);\n  const uint32_t func = ERR_GET_FUNC(packed_error);\n\n  if (lib == ERR_LIB_SYS) {\n    switch (func) {\n      case SYS_F_fopen:\n        return \"fopen\";\n      case SYS_F_fclose:\n        return \"fclose\";\n      case SYS_F_fread:\n        return \"fread\";\n      case SYS_F_fwrite:\n        return \"fwrite\";\n      case SYS_F_socket:\n        return \"socket\";\n      case SYS_F_setsockopt:\n        return \"setsockopt\";\n      case SYS_F_connect:\n        return \"connect\";\n      case SYS_F_getaddrinfo:\n        return \"getaddrinfo\";\n      default:\n        return NULL;\n    }\n  }\n\n  return err_string_lookup(ERR_GET_LIB(packed_error),\n                           ERR_GET_FUNC(packed_error), kFunctionValues,\n                           sizeof(kFunctionValues) / sizeof(kFunctionValues[0]),\n                           kFunctionStringData);\n}\n\nconst char *ERR_reason_error_string(uint32_t packed_error) {\n  const uint32_t lib = ERR_GET_LIB(packed_error);\n  const uint32_t reason = ERR_GET_REASON(packed_error);\n\n  if (lib == ERR_LIB_SYS) {\n    if (reason < 127) {\n      return strerror(reason);\n    }\n    return NULL;\n  }\n\n  if (reason < ERR_NUM_LIBS) {\n    return kLibraryNames[reason];\n  }\n\n  if (reason < 100) {\n    switch (reason) {\n      case ERR_R_MALLOC_FAILURE:\n        return \"malloc failure\";\n      case ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED:\n        return \"function should not have been called\";\n      case ERR_R_PASSED_NULL_PARAMETER:\n        return \"passed a null parameter\";\n      case ERR_R_INTERNAL_ERROR:\n        return \"internal error\";\n      case ERR_R_OVERFLOW:\n        return \"overflow\";\n      default:\n        return NULL;\n    }\n  }\n\n  return err_string_lookup(lib, reason, kReasonValues,\n                           sizeof(kReasonValues) / sizeof(kReasonValues[0]),\n                           kReasonStringData);\n}\n\nvoid ERR_print_errors_cb(ERR_print_errors_callback_t callback, void *ctx) {\n  CRYPTO_THREADID current_thread;\n  char buf[ERR_ERROR_STRING_BUF_LEN];\n  char buf2[1024];\n  unsigned long thread_hash;\n  const char *file, *data;\n  int line, flags;\n  uint32_t packed_error;\n\n  CRYPTO_THREADID_current(&current_thread);\n  thread_hash = CRYPTO_THREADID_hash(&current_thread);\n\n  for (;;) {\n    packed_error = ERR_get_error_line_data(&file, &line, &data, &flags);\n    if (packed_error == 0) {\n      break;\n    }\n\n    ERR_error_string_n(packed_error, buf, sizeof(buf));\n    BIO_snprintf(buf2, sizeof(buf2), \"%lu:%s:%s:%d:%s\\n\", thread_hash, buf,\n                 file, line, (flags & ERR_FLAG_STRING) ? data : \"\");\n    if (callback(buf2, strlen(buf2), ctx) <= 0) {\n      break;\n    }\n  }\n}\n\n/* err_set_error_data sets the data on the most recent error. The |flags|\n * argument is a combination of the |ERR_FLAG_*| values. */\nstatic void err_set_error_data(char *data, int flags) {\n  ERR_STATE *const state = err_get_state();\n  struct err_error_st *error;\n\n  if (state == NULL || state->top == state->bottom) {\n    if (flags & ERR_FLAG_MALLOCED) {\n      OPENSSL_free(data);\n    }\n    return;\n  }\n\n  error = &state->errors[state->top];\n\n  err_clear_data(error);\n  error->data = data;\n  error->flags = flags;\n}\n\nvoid ERR_put_error(int library, int func, int reason, const char *file,\n                   unsigned line) {\n  ERR_STATE *const state = err_get_state();\n  struct err_error_st *error;\n\n  if (state == NULL) {\n    return;\n  }\n\n  if (library == ERR_LIB_SYS && reason == 0) {\n#if defined(WIN32)\n    reason = GetLastError();\n#else\n    reason = errno;\n#endif\n  }\n\n  state->top = (state->top + 1) % ERR_NUM_ERRORS;\n  if (state->top == state->bottom) {\n    state->bottom = (state->bottom + 1) % ERR_NUM_ERRORS;\n  }\n\n  error = &state->errors[state->top];\n  err_clear(error);\n  error->file = file;\n  error->line = line;\n  error->packed = ERR_PACK(library, func, reason);\n}\n\n/* ERR_add_error_data_vdata takes a variable number of const char* pointers,\n * concatenates them and sets the result as the data on the most recent\n * error. */\nstatic void err_add_error_vdata(unsigned num, va_list args) {\n  size_t alloced, new_len, len = 0, substr_len;\n  char *buf;\n  const char *substr;\n  unsigned i;\n\n  alloced = 80;\n  buf = OPENSSL_malloc(alloced + 1);\n  if (buf == NULL) {\n    return;\n  }\n\n  for (i = 0; i < num; i++) {\n    substr = va_arg(args, const char *);\n    if (substr == NULL) {\n      continue;\n    }\n\n    substr_len = strlen(substr);\n    new_len = len + substr_len;\n    if (new_len > alloced) {\n      char *new_buf;\n\n      if (alloced + 20 + 1 < alloced) {\n        /* overflow. */\n        OPENSSL_free(buf);\n        return;\n      }\n\n      alloced = new_len + 20;\n      new_buf = OPENSSL_realloc(buf, alloced + 1);\n      if (new_buf == NULL) {\n        OPENSSL_free(buf);\n        return;\n      }\n      buf = new_buf;\n    }\n\n    memcpy(buf + len, substr, substr_len);\n    len = new_len;\n  }\n\n  buf[len] = 0;\n  err_set_error_data(buf, ERR_FLAG_MALLOCED | ERR_FLAG_STRING);\n}\n\nvoid ERR_add_error_data(unsigned count, ...) {\n  va_list args;\n  va_start(args, count);\n  err_add_error_vdata(count, args);\n  va_end(args);\n}\n\nvoid ERR_add_error_dataf(const char *format, ...) {\n  va_list ap;\n  char *buf;\n  static const unsigned buf_len = 256;\n\n  /* A fixed-size buffer is used because va_copy (which would be needed in\n   * order to call vsnprintf twice and measure the buffer) wasn't defined until\n   * C99. */\n  buf = OPENSSL_malloc(buf_len + 1);\n  if (buf == NULL) {\n    return;\n  }\n\n  va_start(ap, format);\n  BIO_vsnprintf(buf, buf_len, format, ap);\n  buf[buf_len] = 0;\n  va_end(ap);\n\n  err_set_error_data(buf, ERR_FLAG_MALLOCED | ERR_FLAG_STRING);\n}\n\nint ERR_set_mark(void) {\n  ERR_STATE *const state = err_get_state();\n\n  if (state == NULL || state->bottom == state->top) {\n    return 0;\n  }\n  state->errors[state->top].flags |= ERR_FLAG_MARK;\n  return 1;\n}\n\nint ERR_pop_to_mark(void) {\n  ERR_STATE *const state = err_get_state();\n\n  if (state == NULL) {\n    return 0;\n  }\n\n  while (state->bottom != state->top) {\n    struct err_error_st *error = &state->errors[state->top];\n\n    if ((error->flags & ERR_FLAG_MARK) != 0) {\n      error->flags &= ~ERR_FLAG_MARK;\n      return 1;\n    }\n\n    err_clear(error);\n    if (state->top == 0) {\n      state->top = ERR_NUM_ERRORS - 1;\n    } else {\n      state->top--;\n    }\n  }\n\n  return 0;\n}\n\nvoid ERR_load_crypto_strings(void) {}\n\nvoid ERR_free_strings(void) {\n  err_fns_check();\n  ERRFN(shutdown)(err_state_free);\n}\n\nvoid ERR_load_BIO_strings(void) {}\n
===================================================================
--- crypto/err/err.c	(revision 5f237bc843f4a4791667493d8748c903b8e540e4)
+++ crypto/err/err.c	(revision )
@@ -425,8 +425,8 @@
 
 #include "err_data.h"
 
-// err_string_cmp is a compare function for searching error values with
-// |bsearch| in |err_string_lookup|.
+/* err_string_cmp is a compare function for searching error values with
+ * |bsearch| in |err_string_lookup|. */
 static int err_string_cmp(const void *a, const void *b) {
   const uint32_t a_key = *((const uint32_t*) a) >> 15;
   const uint32_t b_key = *((const uint32_t*) b) >> 15;
